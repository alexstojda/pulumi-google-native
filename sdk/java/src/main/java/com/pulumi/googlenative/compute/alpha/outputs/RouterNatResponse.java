// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.compute.alpha.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.googlenative.compute.alpha.outputs.RouterNatLogConfigResponse;
import com.pulumi.googlenative.compute.alpha.outputs.RouterNatRuleResponse;
import com.pulumi.googlenative.compute.alpha.outputs.RouterNatSubnetworkToNatResponse;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;

@CustomType
public final class RouterNatResponse {
    /**
     * @return A list of URLs of the IP resources to be drained. These IPs must be valid static external IPs that have been assigned to the NAT. These IPs should be used for updating/patching a NAT only.
     * 
     */
    private List<String> drainNatIps;
    /**
     * @return Enable Dynamic Port Allocation. If not specified, it is disabled by default. If set to true, - Dynamic Port Allocation will be enabled on this NAT config. - enableEndpointIndependentMapping cannot be set to true. - If minPorts is set, minPortsPerVm must be set to a power of two greater than or equal to 32. If minPortsPerVm is not set, a minimum of 32 ports will be allocated to a VM from this NAT config.
     * 
     */
    private Boolean enableDynamicPortAllocation;
    private Boolean enableEndpointIndependentMapping;
    /**
     * @return List of NAT-ted endpoint types supported by the Nat Gateway. If the list is empty, then it will be equivalent to include ENDPOINT_TYPE_VM
     * 
     */
    private List<String> endpointTypes;
    /**
     * @return Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
     * 
     */
    private Integer icmpIdleTimeoutSec;
    /**
     * @return Configure logging on this NAT.
     * 
     */
    private RouterNatLogConfigResponse logConfig;
    /**
     * @return Maximum number of ports allocated to a VM from this NAT config when Dynamic Port Allocation is enabled. If Dynamic Port Allocation is not enabled, this field has no effect. If Dynamic Port Allocation is enabled, and this field is set, it must be set to a power of two greater than minPortsPerVm, or 64 if minPortsPerVm is not set. If Dynamic Port Allocation is enabled and this field is not set, a maximum of 65536 ports will be allocated to a VM from this NAT config.
     * 
     */
    private Integer maxPortsPerVm;
    /**
     * @return Minimum number of ports allocated to a VM from this NAT config. If not set, a default number of ports is allocated to a VM. This is rounded up to the nearest power of 2. For example, if the value of this field is 50, at least 64 ports are allocated to a VM.
     * 
     */
    private Integer minPortsPerVm;
    /**
     * @return Unique name of this Nat service. The name must be 1-63 characters long and comply with RFC1035.
     * 
     */
    private String name;
    /**
     * @return Specify the NatIpAllocateOption, which can take one of the following values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can&#39;t specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty.
     * 
     */
    private String natIpAllocateOption;
    /**
     * @return A list of URLs of the IP resources used for this Nat service. These IP addresses must be valid static external IP addresses assigned to the project.
     * 
     */
    private List<String> natIps;
    /**
     * @return A list of rules associated with this NAT.
     * 
     */
    private List<RouterNatRuleResponse> rules;
    /**
     * @return Specify the Nat option, which can take one of the following values: - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other Router.Nat section in any Router for this network in this region.
     * 
     */
    private String sourceSubnetworkIpRangesToNat;
    /**
     * @return A list of Subnetwork resources whose traffic should be translated by NAT Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the SubnetworkIpRangeToNatOption above.
     * 
     */
    private List<RouterNatSubnetworkToNatResponse> subnetworks;
    /**
     * @return Timeout (in seconds) for TCP established connections. Defaults to 1200s if not set.
     * 
     */
    private Integer tcpEstablishedIdleTimeoutSec;
    /**
     * @return Timeout (in seconds) for TCP connections that are in TIME_WAIT state. Defaults to 120s if not set.
     * 
     */
    private Integer tcpTimeWaitTimeoutSec;
    /**
     * @return Timeout (in seconds) for TCP transitory connections. Defaults to 30s if not set.
     * 
     */
    private Integer tcpTransitoryIdleTimeoutSec;
    /**
     * @return Indicates whether this NAT is used for public or private IP translation. If unspecified, it defaults to PUBLIC.
     * 
     */
    private String type;
    /**
     * @return Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
     * 
     */
    private Integer udpIdleTimeoutSec;

    private RouterNatResponse() {}
    /**
     * @return A list of URLs of the IP resources to be drained. These IPs must be valid static external IPs that have been assigned to the NAT. These IPs should be used for updating/patching a NAT only.
     * 
     */
    public List<String> drainNatIps() {
        return this.drainNatIps;
    }
    /**
     * @return Enable Dynamic Port Allocation. If not specified, it is disabled by default. If set to true, - Dynamic Port Allocation will be enabled on this NAT config. - enableEndpointIndependentMapping cannot be set to true. - If minPorts is set, minPortsPerVm must be set to a power of two greater than or equal to 32. If minPortsPerVm is not set, a minimum of 32 ports will be allocated to a VM from this NAT config.
     * 
     */
    public Boolean enableDynamicPortAllocation() {
        return this.enableDynamicPortAllocation;
    }
    public Boolean enableEndpointIndependentMapping() {
        return this.enableEndpointIndependentMapping;
    }
    /**
     * @return List of NAT-ted endpoint types supported by the Nat Gateway. If the list is empty, then it will be equivalent to include ENDPOINT_TYPE_VM
     * 
     */
    public List<String> endpointTypes() {
        return this.endpointTypes;
    }
    /**
     * @return Timeout (in seconds) for ICMP connections. Defaults to 30s if not set.
     * 
     */
    public Integer icmpIdleTimeoutSec() {
        return this.icmpIdleTimeoutSec;
    }
    /**
     * @return Configure logging on this NAT.
     * 
     */
    public RouterNatLogConfigResponse logConfig() {
        return this.logConfig;
    }
    /**
     * @return Maximum number of ports allocated to a VM from this NAT config when Dynamic Port Allocation is enabled. If Dynamic Port Allocation is not enabled, this field has no effect. If Dynamic Port Allocation is enabled, and this field is set, it must be set to a power of two greater than minPortsPerVm, or 64 if minPortsPerVm is not set. If Dynamic Port Allocation is enabled and this field is not set, a maximum of 65536 ports will be allocated to a VM from this NAT config.
     * 
     */
    public Integer maxPortsPerVm() {
        return this.maxPortsPerVm;
    }
    /**
     * @return Minimum number of ports allocated to a VM from this NAT config. If not set, a default number of ports is allocated to a VM. This is rounded up to the nearest power of 2. For example, if the value of this field is 50, at least 64 ports are allocated to a VM.
     * 
     */
    public Integer minPortsPerVm() {
        return this.minPortsPerVm;
    }
    /**
     * @return Unique name of this Nat service. The name must be 1-63 characters long and comply with RFC1035.
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return Specify the NatIpAllocateOption, which can take one of the following values: - MANUAL_ONLY: Uses only Nat IP addresses provided by customers. When there are not enough specified Nat IPs, the Nat service fails for new VMs. - AUTO_ONLY: Nat IPs are allocated by Google Cloud Platform; customers can&#39;t specify any Nat IPs. When choosing AUTO_ONLY, then nat_ip should be empty.
     * 
     */
    public String natIpAllocateOption() {
        return this.natIpAllocateOption;
    }
    /**
     * @return A list of URLs of the IP resources used for this Nat service. These IP addresses must be valid static external IP addresses assigned to the project.
     * 
     */
    public List<String> natIps() {
        return this.natIps;
    }
    /**
     * @return A list of rules associated with this NAT.
     * 
     */
    public List<RouterNatRuleResponse> rules() {
        return this.rules;
    }
    /**
     * @return Specify the Nat option, which can take one of the following values: - ALL_SUBNETWORKS_ALL_IP_RANGES: All of the IP ranges in every Subnetwork are allowed to Nat. - ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES: All of the primary IP ranges in every Subnetwork are allowed to Nat. - LIST_OF_SUBNETWORKS: A list of Subnetworks are allowed to Nat (specified in the field subnetwork below) The default is SUBNETWORK_IP_RANGE_TO_NAT_OPTION_UNSPECIFIED. Note that if this field contains ALL_SUBNETWORKS_ALL_IP_RANGES or ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES, then there should not be any other Router.Nat section in any Router for this network in this region.
     * 
     */
    public String sourceSubnetworkIpRangesToNat() {
        return this.sourceSubnetworkIpRangesToNat;
    }
    /**
     * @return A list of Subnetwork resources whose traffic should be translated by NAT Gateway. It is used only when LIST_OF_SUBNETWORKS is selected for the SubnetworkIpRangeToNatOption above.
     * 
     */
    public List<RouterNatSubnetworkToNatResponse> subnetworks() {
        return this.subnetworks;
    }
    /**
     * @return Timeout (in seconds) for TCP established connections. Defaults to 1200s if not set.
     * 
     */
    public Integer tcpEstablishedIdleTimeoutSec() {
        return this.tcpEstablishedIdleTimeoutSec;
    }
    /**
     * @return Timeout (in seconds) for TCP connections that are in TIME_WAIT state. Defaults to 120s if not set.
     * 
     */
    public Integer tcpTimeWaitTimeoutSec() {
        return this.tcpTimeWaitTimeoutSec;
    }
    /**
     * @return Timeout (in seconds) for TCP transitory connections. Defaults to 30s if not set.
     * 
     */
    public Integer tcpTransitoryIdleTimeoutSec() {
        return this.tcpTransitoryIdleTimeoutSec;
    }
    /**
     * @return Indicates whether this NAT is used for public or private IP translation. If unspecified, it defaults to PUBLIC.
     * 
     */
    public String type() {
        return this.type;
    }
    /**
     * @return Timeout (in seconds) for UDP connections. Defaults to 30s if not set.
     * 
     */
    public Integer udpIdleTimeoutSec() {
        return this.udpIdleTimeoutSec;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(RouterNatResponse defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private List<String> drainNatIps;
        private Boolean enableDynamicPortAllocation;
        private Boolean enableEndpointIndependentMapping;
        private List<String> endpointTypes;
        private Integer icmpIdleTimeoutSec;
        private RouterNatLogConfigResponse logConfig;
        private Integer maxPortsPerVm;
        private Integer minPortsPerVm;
        private String name;
        private String natIpAllocateOption;
        private List<String> natIps;
        private List<RouterNatRuleResponse> rules;
        private String sourceSubnetworkIpRangesToNat;
        private List<RouterNatSubnetworkToNatResponse> subnetworks;
        private Integer tcpEstablishedIdleTimeoutSec;
        private Integer tcpTimeWaitTimeoutSec;
        private Integer tcpTransitoryIdleTimeoutSec;
        private String type;
        private Integer udpIdleTimeoutSec;
        public Builder() {}
        public Builder(RouterNatResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.drainNatIps = defaults.drainNatIps;
    	      this.enableDynamicPortAllocation = defaults.enableDynamicPortAllocation;
    	      this.enableEndpointIndependentMapping = defaults.enableEndpointIndependentMapping;
    	      this.endpointTypes = defaults.endpointTypes;
    	      this.icmpIdleTimeoutSec = defaults.icmpIdleTimeoutSec;
    	      this.logConfig = defaults.logConfig;
    	      this.maxPortsPerVm = defaults.maxPortsPerVm;
    	      this.minPortsPerVm = defaults.minPortsPerVm;
    	      this.name = defaults.name;
    	      this.natIpAllocateOption = defaults.natIpAllocateOption;
    	      this.natIps = defaults.natIps;
    	      this.rules = defaults.rules;
    	      this.sourceSubnetworkIpRangesToNat = defaults.sourceSubnetworkIpRangesToNat;
    	      this.subnetworks = defaults.subnetworks;
    	      this.tcpEstablishedIdleTimeoutSec = defaults.tcpEstablishedIdleTimeoutSec;
    	      this.tcpTimeWaitTimeoutSec = defaults.tcpTimeWaitTimeoutSec;
    	      this.tcpTransitoryIdleTimeoutSec = defaults.tcpTransitoryIdleTimeoutSec;
    	      this.type = defaults.type;
    	      this.udpIdleTimeoutSec = defaults.udpIdleTimeoutSec;
        }

        @CustomType.Setter
        public Builder drainNatIps(List<String> drainNatIps) {
            this.drainNatIps = Objects.requireNonNull(drainNatIps);
            return this;
        }
        public Builder drainNatIps(String... drainNatIps) {
            return drainNatIps(List.of(drainNatIps));
        }
        @CustomType.Setter
        public Builder enableDynamicPortAllocation(Boolean enableDynamicPortAllocation) {
            this.enableDynamicPortAllocation = Objects.requireNonNull(enableDynamicPortAllocation);
            return this;
        }
        @CustomType.Setter
        public Builder enableEndpointIndependentMapping(Boolean enableEndpointIndependentMapping) {
            this.enableEndpointIndependentMapping = Objects.requireNonNull(enableEndpointIndependentMapping);
            return this;
        }
        @CustomType.Setter
        public Builder endpointTypes(List<String> endpointTypes) {
            this.endpointTypes = Objects.requireNonNull(endpointTypes);
            return this;
        }
        public Builder endpointTypes(String... endpointTypes) {
            return endpointTypes(List.of(endpointTypes));
        }
        @CustomType.Setter
        public Builder icmpIdleTimeoutSec(Integer icmpIdleTimeoutSec) {
            this.icmpIdleTimeoutSec = Objects.requireNonNull(icmpIdleTimeoutSec);
            return this;
        }
        @CustomType.Setter
        public Builder logConfig(RouterNatLogConfigResponse logConfig) {
            this.logConfig = Objects.requireNonNull(logConfig);
            return this;
        }
        @CustomType.Setter
        public Builder maxPortsPerVm(Integer maxPortsPerVm) {
            this.maxPortsPerVm = Objects.requireNonNull(maxPortsPerVm);
            return this;
        }
        @CustomType.Setter
        public Builder minPortsPerVm(Integer minPortsPerVm) {
            this.minPortsPerVm = Objects.requireNonNull(minPortsPerVm);
            return this;
        }
        @CustomType.Setter
        public Builder name(String name) {
            this.name = Objects.requireNonNull(name);
            return this;
        }
        @CustomType.Setter
        public Builder natIpAllocateOption(String natIpAllocateOption) {
            this.natIpAllocateOption = Objects.requireNonNull(natIpAllocateOption);
            return this;
        }
        @CustomType.Setter
        public Builder natIps(List<String> natIps) {
            this.natIps = Objects.requireNonNull(natIps);
            return this;
        }
        public Builder natIps(String... natIps) {
            return natIps(List.of(natIps));
        }
        @CustomType.Setter
        public Builder rules(List<RouterNatRuleResponse> rules) {
            this.rules = Objects.requireNonNull(rules);
            return this;
        }
        public Builder rules(RouterNatRuleResponse... rules) {
            return rules(List.of(rules));
        }
        @CustomType.Setter
        public Builder sourceSubnetworkIpRangesToNat(String sourceSubnetworkIpRangesToNat) {
            this.sourceSubnetworkIpRangesToNat = Objects.requireNonNull(sourceSubnetworkIpRangesToNat);
            return this;
        }
        @CustomType.Setter
        public Builder subnetworks(List<RouterNatSubnetworkToNatResponse> subnetworks) {
            this.subnetworks = Objects.requireNonNull(subnetworks);
            return this;
        }
        public Builder subnetworks(RouterNatSubnetworkToNatResponse... subnetworks) {
            return subnetworks(List.of(subnetworks));
        }
        @CustomType.Setter
        public Builder tcpEstablishedIdleTimeoutSec(Integer tcpEstablishedIdleTimeoutSec) {
            this.tcpEstablishedIdleTimeoutSec = Objects.requireNonNull(tcpEstablishedIdleTimeoutSec);
            return this;
        }
        @CustomType.Setter
        public Builder tcpTimeWaitTimeoutSec(Integer tcpTimeWaitTimeoutSec) {
            this.tcpTimeWaitTimeoutSec = Objects.requireNonNull(tcpTimeWaitTimeoutSec);
            return this;
        }
        @CustomType.Setter
        public Builder tcpTransitoryIdleTimeoutSec(Integer tcpTransitoryIdleTimeoutSec) {
            this.tcpTransitoryIdleTimeoutSec = Objects.requireNonNull(tcpTransitoryIdleTimeoutSec);
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        @CustomType.Setter
        public Builder udpIdleTimeoutSec(Integer udpIdleTimeoutSec) {
            this.udpIdleTimeoutSec = Objects.requireNonNull(udpIdleTimeoutSec);
            return this;
        }
        public RouterNatResponse build() {
            final var o = new RouterNatResponse();
            o.drainNatIps = drainNatIps;
            o.enableDynamicPortAllocation = enableDynamicPortAllocation;
            o.enableEndpointIndependentMapping = enableEndpointIndependentMapping;
            o.endpointTypes = endpointTypes;
            o.icmpIdleTimeoutSec = icmpIdleTimeoutSec;
            o.logConfig = logConfig;
            o.maxPortsPerVm = maxPortsPerVm;
            o.minPortsPerVm = minPortsPerVm;
            o.name = name;
            o.natIpAllocateOption = natIpAllocateOption;
            o.natIps = natIps;
            o.rules = rules;
            o.sourceSubnetworkIpRangesToNat = sourceSubnetworkIpRangesToNat;
            o.subnetworks = subnetworks;
            o.tcpEstablishedIdleTimeoutSec = tcpEstablishedIdleTimeoutSec;
            o.tcpTimeWaitTimeoutSec = tcpTimeWaitTimeoutSec;
            o.tcpTransitoryIdleTimeoutSec = tcpTransitoryIdleTimeoutSec;
            o.type = type;
            o.udpIdleTimeoutSec = udpIdleTimeoutSec;
            return o;
        }
    }
}
