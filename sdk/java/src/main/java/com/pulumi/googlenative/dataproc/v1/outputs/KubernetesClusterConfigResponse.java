// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.dataproc.v1.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.googlenative.dataproc.v1.outputs.GkeClusterConfigResponse;
import com.pulumi.googlenative.dataproc.v1.outputs.KubernetesSoftwareConfigResponse;
import java.lang.String;
import java.util.Objects;

@CustomType
public final class KubernetesClusterConfigResponse {
    /**
     * @return The configuration for running the Dataproc cluster on GKE.
     * 
     */
    private GkeClusterConfigResponse gkeClusterConfig;
    /**
     * @return Optional. A namespace within the Kubernetes cluster to deploy into. If this namespace does not exist, it is created. If it exists, Dataproc verifies that another Dataproc VirtualCluster is not installed into it. If not specified, the name of the Dataproc Cluster is used.
     * 
     */
    private String kubernetesNamespace;
    /**
     * @return Optional. The software configuration for this Dataproc cluster running on Kubernetes.
     * 
     */
    private KubernetesSoftwareConfigResponse kubernetesSoftwareConfig;

    private KubernetesClusterConfigResponse() {}
    /**
     * @return The configuration for running the Dataproc cluster on GKE.
     * 
     */
    public GkeClusterConfigResponse gkeClusterConfig() {
        return this.gkeClusterConfig;
    }
    /**
     * @return Optional. A namespace within the Kubernetes cluster to deploy into. If this namespace does not exist, it is created. If it exists, Dataproc verifies that another Dataproc VirtualCluster is not installed into it. If not specified, the name of the Dataproc Cluster is used.
     * 
     */
    public String kubernetesNamespace() {
        return this.kubernetesNamespace;
    }
    /**
     * @return Optional. The software configuration for this Dataproc cluster running on Kubernetes.
     * 
     */
    public KubernetesSoftwareConfigResponse kubernetesSoftwareConfig() {
        return this.kubernetesSoftwareConfig;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(KubernetesClusterConfigResponse defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private GkeClusterConfigResponse gkeClusterConfig;
        private String kubernetesNamespace;
        private KubernetesSoftwareConfigResponse kubernetesSoftwareConfig;
        public Builder() {}
        public Builder(KubernetesClusterConfigResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.gkeClusterConfig = defaults.gkeClusterConfig;
    	      this.kubernetesNamespace = defaults.kubernetesNamespace;
    	      this.kubernetesSoftwareConfig = defaults.kubernetesSoftwareConfig;
        }

        @CustomType.Setter
        public Builder gkeClusterConfig(GkeClusterConfigResponse gkeClusterConfig) {
            this.gkeClusterConfig = Objects.requireNonNull(gkeClusterConfig);
            return this;
        }
        @CustomType.Setter
        public Builder kubernetesNamespace(String kubernetesNamespace) {
            this.kubernetesNamespace = Objects.requireNonNull(kubernetesNamespace);
            return this;
        }
        @CustomType.Setter
        public Builder kubernetesSoftwareConfig(KubernetesSoftwareConfigResponse kubernetesSoftwareConfig) {
            this.kubernetesSoftwareConfig = Objects.requireNonNull(kubernetesSoftwareConfig);
            return this;
        }
        public KubernetesClusterConfigResponse build() {
            final var o = new KubernetesClusterConfigResponse();
            o.gkeClusterConfig = gkeClusterConfig;
            o.kubernetesNamespace = kubernetesNamespace;
            o.kubernetesSoftwareConfig = kubernetesSoftwareConfig;
            return o;
        }
    }
}
