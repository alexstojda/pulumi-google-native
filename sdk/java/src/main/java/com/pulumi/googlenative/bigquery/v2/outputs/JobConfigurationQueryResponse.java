// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.bigquery.v2.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.googlenative.bigquery.v2.outputs.ClusteringResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ConnectionPropertyResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.DatasetReferenceResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.EncryptionConfigurationResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.QueryParameterResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.RangePartitioningResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TableReferenceResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TimePartitioningResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.UserDefinedFunctionResourceResponse;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class JobConfigurationQueryResponse {
    /**
     * @return [Optional] If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
     * 
     */
    private Boolean allowLargeResults;
    /**
     * @return [Beta] Clustering specification for the destination table. Must be specified with time-based partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    private ClusteringResponse clustering;
    /**
     * @return Connection properties.
     * 
     */
    private List<ConnectionPropertyResponse> connectionProperties;
    /**
     * @return [Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a &#39;notFound&#39; error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    private String createDisposition;
    /**
     * @return If true, creates a new session, where session id will be a server generated random id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode.
     * 
     */
    private Boolean createSession;
    /**
     * @return [Optional] Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
     * 
     */
    private DatasetReferenceResponse defaultDataset;
    /**
     * @return Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    private EncryptionConfigurationResponse destinationEncryptionConfiguration;
    /**
     * @return [Optional] Describes the table where the query results should be stored. If not present, a new table will be created to store the results. This property must be set for large results that exceed the maximum response size.
     * 
     */
    private TableReferenceResponse destinationTable;
    /**
     * @return [Optional] If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
     * 
     */
    private Boolean flattenResults;
    /**
     * @return [Optional] Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    private Integer maximumBillingTier;
    /**
     * @return [Optional] Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    private String maximumBytesBilled;
    /**
     * @return Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
     * 
     */
    private String parameterMode;
    /**
     * @return [Deprecated] This property is deprecated.
     * 
     * @deprecated
     * [Deprecated] This property is deprecated.
     * 
     */
    @Deprecated /* [Deprecated] This property is deprecated. */
    private Boolean preserveNulls;
    /**
     * @return [Optional] Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
     * 
     */
    private String priority;
    /**
     * @return [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
     * 
     */
    private String query;
    /**
     * @return Query parameters for standard SQL queries.
     * 
     */
    private List<QueryParameterResponse> queryParameters;
    /**
     * @return [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    private RangePartitioningResponse rangePartitioning;
    /**
     * @return Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
     * 
     */
    private List<String> schemaUpdateOptions;
    /**
     * @return [Optional] If querying an external data source outside of BigQuery, describes the data format, location and other properties of the data source. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    private Map<String,String> tableDefinitions;
    /**
     * @return Time-based partitioning specification for the destination table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    private TimePartitioningResponse timePartitioning;
    /**
     * @return Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s standard SQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
     * 
     */
    private Boolean useLegacySql;
    /**
     * @return [Optional] Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
     * 
     */
    private Boolean useQueryCache;
    /**
     * @return Describes user-defined function resources used in the query.
     * 
     */
    private List<UserDefinedFunctionResourceResponse> userDefinedFunctionResources;
    /**
     * @return [Optional] Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a &#39;duplicate&#39; error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    private String writeDisposition;

    private JobConfigurationQueryResponse() {}
    /**
     * @return [Optional] If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
     * 
     */
    public Boolean allowLargeResults() {
        return this.allowLargeResults;
    }
    /**
     * @return [Beta] Clustering specification for the destination table. Must be specified with time-based partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    public ClusteringResponse clustering() {
        return this.clustering;
    }
    /**
     * @return Connection properties.
     * 
     */
    public List<ConnectionPropertyResponse> connectionProperties() {
        return this.connectionProperties;
    }
    /**
     * @return [Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a &#39;notFound&#39; error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    public String createDisposition() {
        return this.createDisposition;
    }
    /**
     * @return If true, creates a new session, where session id will be a server generated random id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode.
     * 
     */
    public Boolean createSession() {
        return this.createSession;
    }
    /**
     * @return [Optional] Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
     * 
     */
    public DatasetReferenceResponse defaultDataset() {
        return this.defaultDataset;
    }
    /**
     * @return Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    public EncryptionConfigurationResponse destinationEncryptionConfiguration() {
        return this.destinationEncryptionConfiguration;
    }
    /**
     * @return [Optional] Describes the table where the query results should be stored. If not present, a new table will be created to store the results. This property must be set for large results that exceed the maximum response size.
     * 
     */
    public TableReferenceResponse destinationTable() {
        return this.destinationTable;
    }
    /**
     * @return [Optional] If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
     * 
     */
    public Boolean flattenResults() {
        return this.flattenResults;
    }
    /**
     * @return [Optional] Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    public Integer maximumBillingTier() {
        return this.maximumBillingTier;
    }
    /**
     * @return [Optional] Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    public String maximumBytesBilled() {
        return this.maximumBytesBilled;
    }
    /**
     * @return Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
     * 
     */
    public String parameterMode() {
        return this.parameterMode;
    }
    /**
     * @return [Deprecated] This property is deprecated.
     * 
     * @deprecated
     * [Deprecated] This property is deprecated.
     * 
     */
    @Deprecated /* [Deprecated] This property is deprecated. */
    public Boolean preserveNulls() {
        return this.preserveNulls;
    }
    /**
     * @return [Optional] Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
     * 
     */
    public String priority() {
        return this.priority;
    }
    /**
     * @return [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
     * 
     */
    public String query() {
        return this.query;
    }
    /**
     * @return Query parameters for standard SQL queries.
     * 
     */
    public List<QueryParameterResponse> queryParameters() {
        return this.queryParameters;
    }
    /**
     * @return [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public RangePartitioningResponse rangePartitioning() {
        return this.rangePartitioning;
    }
    /**
     * @return Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
     * 
     */
    public List<String> schemaUpdateOptions() {
        return this.schemaUpdateOptions;
    }
    /**
     * @return [Optional] If querying an external data source outside of BigQuery, describes the data format, location and other properties of the data source. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    public Map<String,String> tableDefinitions() {
        return this.tableDefinitions;
    }
    /**
     * @return Time-based partitioning specification for the destination table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public TimePartitioningResponse timePartitioning() {
        return this.timePartitioning;
    }
    /**
     * @return Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s standard SQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
     * 
     */
    public Boolean useLegacySql() {
        return this.useLegacySql;
    }
    /**
     * @return [Optional] Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
     * 
     */
    public Boolean useQueryCache() {
        return this.useQueryCache;
    }
    /**
     * @return Describes user-defined function resources used in the query.
     * 
     */
    public List<UserDefinedFunctionResourceResponse> userDefinedFunctionResources() {
        return this.userDefinedFunctionResources;
    }
    /**
     * @return [Optional] Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a &#39;duplicate&#39; error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    public String writeDisposition() {
        return this.writeDisposition;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(JobConfigurationQueryResponse defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean allowLargeResults;
        private ClusteringResponse clustering;
        private List<ConnectionPropertyResponse> connectionProperties;
        private String createDisposition;
        private Boolean createSession;
        private DatasetReferenceResponse defaultDataset;
        private EncryptionConfigurationResponse destinationEncryptionConfiguration;
        private TableReferenceResponse destinationTable;
        private Boolean flattenResults;
        private Integer maximumBillingTier;
        private String maximumBytesBilled;
        private String parameterMode;
        private Boolean preserveNulls;
        private String priority;
        private String query;
        private List<QueryParameterResponse> queryParameters;
        private RangePartitioningResponse rangePartitioning;
        private List<String> schemaUpdateOptions;
        private Map<String,String> tableDefinitions;
        private TimePartitioningResponse timePartitioning;
        private Boolean useLegacySql;
        private Boolean useQueryCache;
        private List<UserDefinedFunctionResourceResponse> userDefinedFunctionResources;
        private String writeDisposition;
        public Builder() {}
        public Builder(JobConfigurationQueryResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allowLargeResults = defaults.allowLargeResults;
    	      this.clustering = defaults.clustering;
    	      this.connectionProperties = defaults.connectionProperties;
    	      this.createDisposition = defaults.createDisposition;
    	      this.createSession = defaults.createSession;
    	      this.defaultDataset = defaults.defaultDataset;
    	      this.destinationEncryptionConfiguration = defaults.destinationEncryptionConfiguration;
    	      this.destinationTable = defaults.destinationTable;
    	      this.flattenResults = defaults.flattenResults;
    	      this.maximumBillingTier = defaults.maximumBillingTier;
    	      this.maximumBytesBilled = defaults.maximumBytesBilled;
    	      this.parameterMode = defaults.parameterMode;
    	      this.preserveNulls = defaults.preserveNulls;
    	      this.priority = defaults.priority;
    	      this.query = defaults.query;
    	      this.queryParameters = defaults.queryParameters;
    	      this.rangePartitioning = defaults.rangePartitioning;
    	      this.schemaUpdateOptions = defaults.schemaUpdateOptions;
    	      this.tableDefinitions = defaults.tableDefinitions;
    	      this.timePartitioning = defaults.timePartitioning;
    	      this.useLegacySql = defaults.useLegacySql;
    	      this.useQueryCache = defaults.useQueryCache;
    	      this.userDefinedFunctionResources = defaults.userDefinedFunctionResources;
    	      this.writeDisposition = defaults.writeDisposition;
        }

        @CustomType.Setter
        public Builder allowLargeResults(Boolean allowLargeResults) {
            this.allowLargeResults = Objects.requireNonNull(allowLargeResults);
            return this;
        }
        @CustomType.Setter
        public Builder clustering(ClusteringResponse clustering) {
            this.clustering = Objects.requireNonNull(clustering);
            return this;
        }
        @CustomType.Setter
        public Builder connectionProperties(List<ConnectionPropertyResponse> connectionProperties) {
            this.connectionProperties = Objects.requireNonNull(connectionProperties);
            return this;
        }
        public Builder connectionProperties(ConnectionPropertyResponse... connectionProperties) {
            return connectionProperties(List.of(connectionProperties));
        }
        @CustomType.Setter
        public Builder createDisposition(String createDisposition) {
            this.createDisposition = Objects.requireNonNull(createDisposition);
            return this;
        }
        @CustomType.Setter
        public Builder createSession(Boolean createSession) {
            this.createSession = Objects.requireNonNull(createSession);
            return this;
        }
        @CustomType.Setter
        public Builder defaultDataset(DatasetReferenceResponse defaultDataset) {
            this.defaultDataset = Objects.requireNonNull(defaultDataset);
            return this;
        }
        @CustomType.Setter
        public Builder destinationEncryptionConfiguration(EncryptionConfigurationResponse destinationEncryptionConfiguration) {
            this.destinationEncryptionConfiguration = Objects.requireNonNull(destinationEncryptionConfiguration);
            return this;
        }
        @CustomType.Setter
        public Builder destinationTable(TableReferenceResponse destinationTable) {
            this.destinationTable = Objects.requireNonNull(destinationTable);
            return this;
        }
        @CustomType.Setter
        public Builder flattenResults(Boolean flattenResults) {
            this.flattenResults = Objects.requireNonNull(flattenResults);
            return this;
        }
        @CustomType.Setter
        public Builder maximumBillingTier(Integer maximumBillingTier) {
            this.maximumBillingTier = Objects.requireNonNull(maximumBillingTier);
            return this;
        }
        @CustomType.Setter
        public Builder maximumBytesBilled(String maximumBytesBilled) {
            this.maximumBytesBilled = Objects.requireNonNull(maximumBytesBilled);
            return this;
        }
        @CustomType.Setter
        public Builder parameterMode(String parameterMode) {
            this.parameterMode = Objects.requireNonNull(parameterMode);
            return this;
        }
        @CustomType.Setter
        public Builder preserveNulls(Boolean preserveNulls) {
            this.preserveNulls = Objects.requireNonNull(preserveNulls);
            return this;
        }
        @CustomType.Setter
        public Builder priority(String priority) {
            this.priority = Objects.requireNonNull(priority);
            return this;
        }
        @CustomType.Setter
        public Builder query(String query) {
            this.query = Objects.requireNonNull(query);
            return this;
        }
        @CustomType.Setter
        public Builder queryParameters(List<QueryParameterResponse> queryParameters) {
            this.queryParameters = Objects.requireNonNull(queryParameters);
            return this;
        }
        public Builder queryParameters(QueryParameterResponse... queryParameters) {
            return queryParameters(List.of(queryParameters));
        }
        @CustomType.Setter
        public Builder rangePartitioning(RangePartitioningResponse rangePartitioning) {
            this.rangePartitioning = Objects.requireNonNull(rangePartitioning);
            return this;
        }
        @CustomType.Setter
        public Builder schemaUpdateOptions(List<String> schemaUpdateOptions) {
            this.schemaUpdateOptions = Objects.requireNonNull(schemaUpdateOptions);
            return this;
        }
        public Builder schemaUpdateOptions(String... schemaUpdateOptions) {
            return schemaUpdateOptions(List.of(schemaUpdateOptions));
        }
        @CustomType.Setter
        public Builder tableDefinitions(Map<String,String> tableDefinitions) {
            this.tableDefinitions = Objects.requireNonNull(tableDefinitions);
            return this;
        }
        @CustomType.Setter
        public Builder timePartitioning(TimePartitioningResponse timePartitioning) {
            this.timePartitioning = Objects.requireNonNull(timePartitioning);
            return this;
        }
        @CustomType.Setter
        public Builder useLegacySql(Boolean useLegacySql) {
            this.useLegacySql = Objects.requireNonNull(useLegacySql);
            return this;
        }
        @CustomType.Setter
        public Builder useQueryCache(Boolean useQueryCache) {
            this.useQueryCache = Objects.requireNonNull(useQueryCache);
            return this;
        }
        @CustomType.Setter
        public Builder userDefinedFunctionResources(List<UserDefinedFunctionResourceResponse> userDefinedFunctionResources) {
            this.userDefinedFunctionResources = Objects.requireNonNull(userDefinedFunctionResources);
            return this;
        }
        public Builder userDefinedFunctionResources(UserDefinedFunctionResourceResponse... userDefinedFunctionResources) {
            return userDefinedFunctionResources(List.of(userDefinedFunctionResources));
        }
        @CustomType.Setter
        public Builder writeDisposition(String writeDisposition) {
            this.writeDisposition = Objects.requireNonNull(writeDisposition);
            return this;
        }
        public JobConfigurationQueryResponse build() {
            final var o = new JobConfigurationQueryResponse();
            o.allowLargeResults = allowLargeResults;
            o.clustering = clustering;
            o.connectionProperties = connectionProperties;
            o.createDisposition = createDisposition;
            o.createSession = createSession;
            o.defaultDataset = defaultDataset;
            o.destinationEncryptionConfiguration = destinationEncryptionConfiguration;
            o.destinationTable = destinationTable;
            o.flattenResults = flattenResults;
            o.maximumBillingTier = maximumBillingTier;
            o.maximumBytesBilled = maximumBytesBilled;
            o.parameterMode = parameterMode;
            o.preserveNulls = preserveNulls;
            o.priority = priority;
            o.query = query;
            o.queryParameters = queryParameters;
            o.rangePartitioning = rangePartitioning;
            o.schemaUpdateOptions = schemaUpdateOptions;
            o.tableDefinitions = tableDefinitions;
            o.timePartitioning = timePartitioning;
            o.useLegacySql = useLegacySql;
            o.useQueryCache = useQueryCache;
            o.userDefinedFunctionResources = userDefinedFunctionResources;
            o.writeDisposition = writeDisposition;
            return o;
        }
    }
}
