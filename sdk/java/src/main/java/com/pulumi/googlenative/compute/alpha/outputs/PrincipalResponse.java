// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.compute.alpha.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class PrincipalResponse {
    /**
     * @return An expression to specify custom condition.
     * 
     */
    private String condition;
    /**
     * @return The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
     * 
     */
    private List<String> groups;
    /**
     * @return IPv4 or IPv6 address or range (In CIDR format)
     * 
     */
    private List<String> ips;
    /**
     * @return The namespaces. Exact match, prefix match, and suffix match are supported.
     * 
     */
    private List<String> namespaces;
    /**
     * @return Negate of groups. Specifies exclusions.
     * 
     */
    private List<String> notGroups;
    /**
     * @return Negate of IPs. Specifies exclusions.
     * 
     */
    private List<String> notIps;
    /**
     * @return Negate of namespaces. Specifies exclusions.
     * 
     */
    private List<String> notNamespaces;
    /**
     * @return Negate of users. Specifies exclusions.
     * 
     */
    private List<String> notUsers;
    /**
     * @return A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
     * 
     */
    private Map<String,String> properties;
    /**
     * @return The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
     * 
     */
    private List<String> users;

    private PrincipalResponse() {}
    /**
     * @return An expression to specify custom condition.
     * 
     */
    public String condition() {
        return this.condition;
    }
    /**
     * @return The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public List<String> groups() {
        return this.groups;
    }
    /**
     * @return IPv4 or IPv6 address or range (In CIDR format)
     * 
     */
    public List<String> ips() {
        return this.ips;
    }
    /**
     * @return The namespaces. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public List<String> namespaces() {
        return this.namespaces;
    }
    /**
     * @return Negate of groups. Specifies exclusions.
     * 
     */
    public List<String> notGroups() {
        return this.notGroups;
    }
    /**
     * @return Negate of IPs. Specifies exclusions.
     * 
     */
    public List<String> notIps() {
        return this.notIps;
    }
    /**
     * @return Negate of namespaces. Specifies exclusions.
     * 
     */
    public List<String> notNamespaces() {
        return this.notNamespaces;
    }
    /**
     * @return Negate of users. Specifies exclusions.
     * 
     */
    public List<String> notUsers() {
        return this.notUsers;
    }
    /**
     * @return A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
     * 
     */
    public Map<String,String> properties() {
        return this.properties;
    }
    /**
     * @return The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public List<String> users() {
        return this.users;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(PrincipalResponse defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String condition;
        private List<String> groups;
        private List<String> ips;
        private List<String> namespaces;
        private List<String> notGroups;
        private List<String> notIps;
        private List<String> notNamespaces;
        private List<String> notUsers;
        private Map<String,String> properties;
        private List<String> users;
        public Builder() {}
        public Builder(PrincipalResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.condition = defaults.condition;
    	      this.groups = defaults.groups;
    	      this.ips = defaults.ips;
    	      this.namespaces = defaults.namespaces;
    	      this.notGroups = defaults.notGroups;
    	      this.notIps = defaults.notIps;
    	      this.notNamespaces = defaults.notNamespaces;
    	      this.notUsers = defaults.notUsers;
    	      this.properties = defaults.properties;
    	      this.users = defaults.users;
        }

        @CustomType.Setter
        public Builder condition(String condition) {
            this.condition = Objects.requireNonNull(condition);
            return this;
        }
        @CustomType.Setter
        public Builder groups(List<String> groups) {
            this.groups = Objects.requireNonNull(groups);
            return this;
        }
        public Builder groups(String... groups) {
            return groups(List.of(groups));
        }
        @CustomType.Setter
        public Builder ips(List<String> ips) {
            this.ips = Objects.requireNonNull(ips);
            return this;
        }
        public Builder ips(String... ips) {
            return ips(List.of(ips));
        }
        @CustomType.Setter
        public Builder namespaces(List<String> namespaces) {
            this.namespaces = Objects.requireNonNull(namespaces);
            return this;
        }
        public Builder namespaces(String... namespaces) {
            return namespaces(List.of(namespaces));
        }
        @CustomType.Setter
        public Builder notGroups(List<String> notGroups) {
            this.notGroups = Objects.requireNonNull(notGroups);
            return this;
        }
        public Builder notGroups(String... notGroups) {
            return notGroups(List.of(notGroups));
        }
        @CustomType.Setter
        public Builder notIps(List<String> notIps) {
            this.notIps = Objects.requireNonNull(notIps);
            return this;
        }
        public Builder notIps(String... notIps) {
            return notIps(List.of(notIps));
        }
        @CustomType.Setter
        public Builder notNamespaces(List<String> notNamespaces) {
            this.notNamespaces = Objects.requireNonNull(notNamespaces);
            return this;
        }
        public Builder notNamespaces(String... notNamespaces) {
            return notNamespaces(List.of(notNamespaces));
        }
        @CustomType.Setter
        public Builder notUsers(List<String> notUsers) {
            this.notUsers = Objects.requireNonNull(notUsers);
            return this;
        }
        public Builder notUsers(String... notUsers) {
            return notUsers(List.of(notUsers));
        }
        @CustomType.Setter
        public Builder properties(Map<String,String> properties) {
            this.properties = Objects.requireNonNull(properties);
            return this;
        }
        @CustomType.Setter
        public Builder users(List<String> users) {
            this.users = Objects.requireNonNull(users);
            return this;
        }
        public Builder users(String... users) {
            return users(List.of(users));
        }
        public PrincipalResponse build() {
            final var o = new PrincipalResponse();
            o.condition = condition;
            o.groups = groups;
            o.ips = ips;
            o.namespaces = namespaces;
            o.notGroups = notGroups;
            o.notIps = notIps;
            o.notNamespaces = notNamespaces;
            o.notUsers = notUsers;
            o.properties = properties;
            o.users = users;
            return o;
        }
    }
}
